По сути, вся криптография, используемая в сети Bitcoin - это так называемая "криптография на эллиптических кривых (ECDSA)". Это тип криптографии основывается на использовании некоторой особой, довольно интересной функции - эллиптической кривой (не путать с эллипсом!).

В этой статье я расскажу, что это за функция, как она работает, что такое приватные / публичные ключи, и как это все выглядит с точки зрения Bitcoin.

![hackerman](https://habrastorage.org/files/a27/ac5/0ad/a27ac50ad5454e3283b5b25795233f59.jpg)

<cut />

### Table of content
1. Elliptic curve
2. Elliptic curve over a finite field
3. SECP256k1
4. ECDSA
5. Private key
6. Public key
7. Signing message
8. Links

### Eliptic curve
> Эллипти́ческая крива́я над полем $K$ — неособая кубическая кривая на проективной плоскости над $ {\hat {K}} $ (алгебраическим замыканием поля $ K $), задаваемая уравнением 3-й степени с коэффициентами из поля $ K $ и «точкой на бесконечности» - [Wikipedia](https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%BB%D0%B8%D0%BF%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BA%D1%80%D0%B8%D0%B2%D0%B0%D1%8F)

Если на пальцах, то эллиптическая кривая - это некоторая довольно простая функция, как правило записываемая в виде так называемой формы Вейерштрасса: $ y^{2}=x^{3}+ax+b $

В зависимости от значений параметров $a$ и $b$, график данной функции может выглядеть по разному:

![elliptic curves](https://habrastorage.org/files/ee8/746/c92/ee8746c9232b4033afd629279d5a3a8b.png)

Скрипт для отрисовки графика на Python:

```python
import numpy as np
import matplotlib.pyplot as plt

def main():
    a = -1
    b = 1

    y, x = np.ogrid[-5:5:100j, -5:5:100j]
    plt.contour(x.ravel(), y.ravel(), pow(y, 2) - pow(x, 3) - x * a - b, [0])
    plt.grid()
    plt.show()

if __name__ == '__main__':
    main()
```

Если верить wiki, то впервые эта функция засветилась еще в древней Греции, где Диофант пытался найти решения уравнения $y(6-y)=x^{3}-x$. Чуть позже, в 17 веке, Ньютон также заинтересовался кубическими кривыми, и его открытия во многом привели в формулам сложения точек на эллиптической кривой, с которыми мы сейчас познакомимся. Здесь и в дальнейшем мы будем рассматривать некоторую эллиптическую кривую $\alpha$.

Пусть есть две точки $P, Q \in \alpha$. Их суммой называется точка $R \in \alpha$, которая в простейшем случае определяется следующим образом: проведем прямую через $P$ и $Q$ - она пересечет кривую $\alpha$ в единственной точке, назовем ее $-R$. Поменяв $y$ координату точки $-R$ на противоположенную по знаку, мы получим точку $R$, которую и будем называть суммой $P$ и $Q$, то есть $P + Q = R$. 

![ellitic_curve_addiction](http://bilmuh.yasar.edu.tr/wp-content/uploads/2015/06/gamze-orhon1.jpg)

Считаю необходимым отметить, что мы именно **вводим** такую операцию сложения - если вы будете складывать точки в привычном понимании, то есть складывая соответствующие координаты, то получите совсем другую точку $R' (x_1 + x_2, y_1 + y_2)$, которая скорее всего не имеет ничего общего с $R$ или $-R$ и  вообще не лежит на кривой $\alpha$.

Самые сообразительные уже задались вопросом - а что будет, если например провести прямую через две точки, имеющие координаты вида $P (a, b)$ и $Q (a, -b)$, то есть прямая, проходящая через них, будет параллельна оси ординат (третий кадр на картинке ниже).

![elliptic_curve_parallel](https://habrastorage.org/files/688/4f9/518/6884f95189be44acae28a94d578c4191.png)

Несложно видеть, что в этом случае отсутствует третье пересечение в кривой $\alpha$, которое мы называли $-R$. Для того, чтобы избежать этого казуса - введем так называемую **точку в бесконечности** (point of infinity), обозначаемую обычно $O$ или просто $0$, как на картинке. И будем говорить, что в случае отсутствия пересечения $P + Q = O$. 

Особый интерес для нас представляет случай, когда мы хотим сложить точку саму с собой (2 кадр, точка $Q$). В этом случае просто проведем касательную к точке $Q$ и отразим полученную точку пересечения относительно $y$.

Теперь, легким движением руки, можно ввести операцию умножения точки на какое-то $\mathbb{N}$ число. В результате получим новую точку $K = G*k$, то есть $K = G + G + ... + G, \ k$ раз. С картинкой все должно стать вообще понятно:

![elliptic_curve_multiplication](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0404.png) 

### Elliptic curve over a finite field
В криптографии использоваться точно такая же кривая, только рассматриваемая над некоторым конечным полем ${F} _{p}=\mathbb{Z} / \mathbb{Z}_p = \{0, 1, ..., p - 1\}, где $ $p$ - простое число. То есть 
$$
y^2\ mod\ p = x^2 + ax + b \ (mod\ p)
$$
Все названные свойства (сложение, умножение, точка в бесконечности) для такой функции остаются в силе, хотя если попробовать нарисовать данную функцию, то напоминать привычную эллиптическую кривую она будет лишь отдаленно (в лучшем случае). А понятие "касательной к функции в точке" вообще теряет всякий смысл, но это ничего страшного. Вот пример функции $y^2 = x^3 + 7$ для $p=17$:

![elliptic_curve_over_17](https://habrastorage.org/files/b88/d43/1ec/b88d431ec74b422c995fe7a95fe4f4d0.png)

А вот для $p=59$, тут вообще почти хаотичный набор точек. Единственное, что все еще напоминает о происхождении этого графика - так это симметрия относительно оси $X$.

![elliptic_curve_59](https://habrastorage.org/files/48a/74b/f17/48a74bf177fc4bb0bfa86678bccf6125.png)

**P. S.** Если вам хочется узнать, как в случае с кривой над конечным полем вычислить координаты точки $R (x_3, y_3)$, зная координаты $P(x_1, y_1)$ и $Q(x_2, y_2)$ - можете полистать ["An Introduction to Bitcoin, Elliptic Curves and the Mathematics of ECDSA" by N. Mistry](http://www.slideshare.net/NikeshMistry1/introduction-to-bitcoin-and-ecdsa), там все подробно расписано, достаточно знать математику на уровне 8 класса.

**P. P. S.** На случай, если мои примеры не удовлетворили ваш пытливый ум - [вот интерактивная рисовалка](https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/modk-add.html) самых разных кривых, поэкспериментируйте.

### SECP256k1
Возвращаясь конкретно к Bitcoin - в нем используется кривая [SECP256k1](https://en.bitcoin.it/wiki/Secp256k1). Она имеет вид $y^2 = x^3 + 7$ и рассматривается над полем $F_p$, где $p$ - очень большое простое число, а именно $2^{256} - 2^{32} - 2^{9} - 2^{8} - 2^{7} - 2^{6} - 2^{4} - 1$. 

Так же для SECP256k1 определена так называемая **base point** , она же **generator point** - это просто точка, как правило обозначаемая $G$, лежащая на данной кривой. Она нужна для создания публичного ключа, о котором будет рассказано ниже.

Еще определен параметр $n$, который называется порядком (**order**) генератора, то есть натуральное число, такое что $n*G=O$.

Простой пример: используя Python, проверим, принадлежит ли точка $G (x, y)$ кривой SECP256k1

```python
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
>>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
>>> (x ** 3 + 7) % p == y**2 % p
True
```

### Digital signature

> Электро́нная по́дпись (ЭП), Электро́нная цифровая по́дпись (ЭЦП) — реквизит электронного документа, полученный в результате криптографического преобразования информации с использованием закрытого ключа подписи и позволяющий проверить отсутствие искажения информации в электронном документе с момента формирования подписи (целостность), принадлежность подписи владельцу сертификата ключа подписи (авторство), а в случае успешной проверки подтвердить факт подписания электронного документа (неотказуемость) - [Wikipedia](https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%B5%D0%BA%D1%82%D1%80%D0%BE%D0%BD%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C)

Общая идея такая - Алиса хочет перевести 1 BTC Бобу. Для этого она создает сообщение типа:

    {
    	"from" : 1FXySbm7jpJfHEJRjSNPPUqnpRTcSuS8aN, // Alice's address
    	"to" : 1Eqm3z1yu6D4Y1c1LXKqReqo1gvZNrmfvN, // Bob's address
    	"amount" : 1 // Send 1 BTC
    }
Потом Алиса берет свой приватный ключ (что это такое я расскажу ниже), хэш сообщения и функцию вида $sign\_text(private\_key, text)$. На выходе она получает некоторую **подпись** (signature) своего сообщения - в случае ECDSA это будет пара целых чисел, для других алгоритмов подпись может выглядеть по другому. После этого она рассылает всем участникам сети исходное сообщение, подпись и свой публичный ключ. В результате, каждый Вася при желании сможет взять эту троицу, функцию вида $validate\_signature(public\_key, signature, text)$ и проверить, действительно ли владелец приватного ключа подписывал это сообщение или нет. А если внутри сети все знают, что $public\_key$ принадлежит Алисе, то можно понять, действительно ли Алиса написала это сообщение, или нет.

![digital_signature_scheme](https://habrastorage.org/files/b23/856/57d/b2385657dd3545998a0b0bc4af4a0fd5.png)

__AHTUNG!__ В реальности процесс довольно существенно отличается от вышеописанного. Здесь я просто на пальцах показал, что из себя представляет электронно цифровая подпись и зачем она нужна. Реальный алгоритм описан в статье ["Bitcoin in a nutshell. Transactions."](#) 

### Private key
**Приватный ключ** - это довольно общий термин и в различных алгоритмах электронной подписи могут использоваться различные типы приватных ключей.

Как вы уже могли заметить, в Bitcoin используется алгоритм ECDSA - в его случае приватный ключ это некоторое натуральное $256$ битное число, то есть самое обычное целое число от $1$ до $2^{256}$. Технически, даже число $123456$ будет являться корректным приватным ключом, но очень скоро вы узнаете, что ваши монеты "принадлежат" вам ровно до того момента, как у злоумышленника окажется ваш приватный ключ, а значения типа $123456$ очень легко перебираются.

Важно отметить, что на сегодняшний день перебрать все ключи невозможно в силу того, что $2^{256}$ - это фантастически большое число. 

Постараемся его представить - согласно [этой статье](http://www.quickanddirtytips.com/education/math/how-many-grains-of-sand-are-on-earth%E2%80%99s-beaches), на всей Земле немногим меньше $10^{22}$ песчинок. Воспользуемся тем, что $2^{10} ≈ 10^3$, то есть $10^{22} ≈ 2^{80}$ песчинок. А всего адресов у нас $2^{256}$, то есть примерно ${2^{80}}^3$.

Значит мы можем взять весь песок на Земле, превратить каждую песчинку в новую Землю, в получившей куче Земель каждую песчинку на каждой планете снова превратить в новую Землю - и суммарное число песчинок все равно будет в разы меньше числа возможных приватных ключей.

По этой же причине, большинство Bitcoin клиентов при создании приватного ключа просто берут $256$ случайных бит - вероятность коллизии крайне мала. 

#### Создание приватного ключа на Python

```python
>>> import random
>>> private_key = ''.join(['%x' % random.randrange(16) for x in range(0, 64)])
>>> private_key
'9ceb87fc34ec40408fd8ab3fa81a93f7b4ebd40bba7811ebef7cbc80252a9815'     
```

#### Создание приватного ключа на Python + [ECDSA](https://github.com/warner/python-ecdsa)

```python
>>> import binascii
>>> import ecdsa # sudo pip install ecdsa
>>> private_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)
>>> binascii.hexlify(private_key.to_string()).decode('ascii').upper()
u'CE47C04A097522D33B4B003B25DD7E8D7945EA52FA8931FD9AA55B315A39DC62'
```

#### Создание приватного ключа с помощью bitcoin-cli

```ba
$ bitcoin-cli getnewaddress
14RVpC4su4PzSafjCKVWP2YBHv3f6zNf6U
$ bitcoin-cli dumpprivkey 14RVpC4su4PzSafjCKVWP2YBHv3f6zNf6U
L3SPdkFWMnFyDGyV3vkCjroGi4zfD59Wsc5CHdB1LirjN6s2vii9
```

### Private key formats

[Самый очевидный способ](https://en.bitcoin.it/wiki/Private_key#An_example_private_key) хранить приватный ключ - это записать 256 бит в виде 32 байт, где каждому байту соответвует два символа в шестнадцатиричной записи, то есть используются цифры `0,1,...,9` и буквы `A,B,C,D,E,F`. Этот формат я использовал в примерах выше, для красоты его еще иногда разделяют пробелами

```
E9 87 3D 79 C6 D8 7D C0 FB 6A 57 78 63 33 89 F4 45 32 13 30 3D A6 1F 20 BD 67 FC 23 3A A3 32 62
```

Другой, более прогрессивный формат - так называемый [WIF](https://en.bitcoin.it/wiki/Wallet_import_format), то есть **Wallet Import Format**. Строится он следующим образом:

1. Берем приватный ключ, например `0C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D`
2. Добавляем байт `0x80`, как идентификатор того, что ключ будет использоваться в *Main net* или `0xEF` для *Test net*. Получается `800C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D`
3. Считаем два раз хэш `SHA-256` и от результата берем первые четыре байта - это **checksum**, в нашем случае `507A5B8D`
4. Добавляем checksum в конец, получается `800C28FCA386C7A227600B2FE50B7CAE11EC86D3BF1FBE471BE89827E19D72AA1D507A5B8D`
5. Конвертируем полученную строку в [Base58Check encoding](https://en.bitcoin.it/wiki/Base58Check_encoding) - `5HueCGU8rMjxEXxiPuD5BDku4MkFqeZyd4dZ1jvhTVqvbTLvyTJ`.

### Base58Check encoding

Суть этой кодировки в том, чтобы записать строку в более коротком виде и при этом уменьшить вероятность возможных опечаток. Вот комментарий из в [base58.h](https://github.com/bitcoin/bitcoin/blob/master/src/base58.h):

> ```
> // Why base-58 instead of standard base-64 encoding?
> // - Don't want 0OIl characters that look the same in some fonts and
> //      could be used to create visually identical looking account numbers.
> // - A string with non-alphanumeric characters is not as easily accepted as an account number.
> // - E-mail usually won't line-break if there's no punctuation to break at.
> // - Doubleclicking selects the whole number as one word if it's all alphanumeric.
> ```

Краткость записи проще всего реализовать, используя довольно распостраненную кодировку [Base64](https://en.wikipedia.org/wiki/Base64), то есть используя систему счисления с основанием 64, где для записи используются цифры `0,1,...,9`, буквы `a-z` и `A-Z` - это дает 62 символа, для оставшихся двух применяют различные символы, в зависимости от реализации. Но есть риск ошибиться из-за похожих символов `0,O` и `I,1`. Поэтому берутся только цифры и буквы за исключением этих четырех - получается 58 символов.

1. ​

### Public key

Пусть $k$ - наш приватный ключ, $G$ - base point, тогда публичный ключ $P=G*k$. То есть фактически, **публичный ключ** - это некоторая точка, лежащая на кривой SECP256k1.

Два важных нюанса. Во-первых, несложно видеть, что операция получения публичного ключа определена однозначно, то есть конкретному приватному ключу всегда соответствует один единственный публичный ключ. Во-вторых, обратная операция является вычислительно трудной и, в общем случае, получить приватный ключ из публичного можно только полным перебором. Это связано с так называемой проблемой дискретного логарифмирования и это именно то, что делает данный алгоритм криптостойким.

В следующей статье вы узнаете, что точно так же дело обстоит и со связкой публичный ключ / адрес.

![keys_to_address](https://habrastorage.org/files/3ff/4e5/f93/3ff4e5f939a847b2aa40bfe4701f4bd9.png)

#### Создание публичного ключа с помощью Python + ECDSA

```python
>>> import binascii
>>> import ecdsa
>>> private_key = ecdsa.SigningKey.generate(curve=ecdsa.SECP256k1)
>>> public_key = private_key.get_verifying_key()
>>> binascii.hexlify(public_key.to_string()).decode('ascii').upper()
u'D5C08F1BFC9C26A5D18FE9254E7923DEBBD34AFB92AC23ABFC6388D2659446C1F04CCDEBB677EAABFED9294663EE79D71B57CA6A6B76BC47E6F8670FE759D746'
>>> # Для наглядности, покажу, как подписываются данные
>>> signature = private_key.sign("message")
>>> binascii.hexlify(signature).decode('ascii')
u'e35319a410c103389611b4d46c34103f3d5ee14906180d06461e7bcf2c296ef83de6dfadc193ea8093ccc40a95b2c77f4d2dd84ec068918c1878282e20044b4a'
>>> public_key.verify(signature, "message") # Иначе был бы exception
True
```

#### Создание публичного ключа на C++, [libbitcoin](https://github.com/libbitcoin/libbitcoin)


```c++
#include <bitcoin/bitcoin.hpp>
#include <iostream>

int main() {
    // Private secret key.
    bc::ec_secret secret = bc::decode_hash(
    "038109007313a5807b2eccc082c8c3fbb988a973cacf1a7df9ce725c31b14776");
    // Get public key.
    bc::ec_point public_key = bc::secret_to_public_key(secret);
    std::cout << "Public key: " << bc::encode_hex(public_key) << std::endl;
}
```

Для компиляции и запуска используем (предварительно установив libbitcoin):

    $ g++ -o public_key <filename> $(pkg-config --cflags --libs libbitcoin)
    $ ./public_key
    Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa

### Sign and verify

### Links

- ["An Introduction to Bitcoin, Elliptic Curves and the Mathematics of ECDSA" by N. Mistry](http://www.slideshare.net/NikeshMistry1/introduction-to-bitcoin-and-ecdsa)
- ["Secure Implementation of ECDSA Signatures in Bitcoin" by Di Wang](http://www.nicolascourtois.com/bitcoin/thesis_Di_Wang.pdf)
- [Private key - Bitcoin wiki](https://en.bitcoin.it/wiki/Private_key)
- [Layman's Guide to Elliptic Curve Digital Signatures](http://royalforkblog.github.io/2014/09/04/ecc/)
