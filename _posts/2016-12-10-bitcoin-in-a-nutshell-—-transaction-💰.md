Если говорить об уже существующей банковской системе, то транзакция внутри какого-нибудь Альфа-банка - это по сути просто редактирование таблицы балансов, где уменьшается число напротив одного имени и увеличивается напротив другого. В случае с межбанковскими переводами подключаются некоторые сторонние организации, например SWIFT, но по сути все работает примерно так же.

Когда мы имеет дело с финансовой системой на основе блокчейна, то процесс денежного перевода выглядит совершенно иначе. В Bitcoin не существует никакой общей таблицы вида <адрес - баланс>, ровно как и не существует регулятора, который бы эту таблицу редактировал. В этой статье я покажу, что из себя представляет транзакция в  Bitcoin, как она проверяется на подлинность и объсню, зачем же внутри Bitcoin добавлен свой язык программирования, про который все слышали, но никто не видел.

![](http://image.slidesharecdn.com/blockchainen-160202215848/95/the-bitcoin-blockchain-en-11-638.jpg?cb=1459267563)

### Table of content
1. Introduction
2. Inputs & outputs
3. Fee
4. UTXO
5. Transaction structure
6. SCRIPT
7. Lock & unlock transaction
8. Password script
9. Pay to Public Key Hash (P2PKH)
10. Links

### Introduction
Как я уже сказал выше - в Bitcoin не существует никакой единой структуры, в которой каждому адресу был бы сопоставлен его текущий баланс. Вместо этого используется тот самый пресловутый блокчейн - то есть хранятся вообще все транзакции. Для простоты пока что можете считать, что это сообщения вида **<address 1> sent <amount\> BTC to <address 2>** плюс подпись сообщения приватным ключом для **<address 1>**. А значит, если пройтись по всему блокчейну, то можно посчитать, сколько монет "принадлежит" конкретному адресу.

### Inputs & outputs
Реальная транзакция в сети Bitcoin на самом деле немного сложнее описанной выше. В действительности, это некоторая громоздкая структура, главными составляющими которой являются входы (inputs) и выходы (outputs).

**Inputs** - это транзакции, на которые вы "ссылаетесь". Представим, что на ваш адрес **X** когда-то было отправлено три транзакции:

- **TXN_ID** - 123456, **VALUE** - 40 BTC
- **TXN_ID** - 6453795, **VALUE** - 10 BTC
- **TXN_ID** - 888888, **VALUE** - 100 BTC

Если вам понадобиться потратить 45 BTC, то вы можете, например, сослаться на транзакцию **888888**, или на две транзакции **123456** и **6453795**. При желании вы можете даже сослаться на все три транзакции, правда непонятно зачем.

**Outputs** - дословно "выходы". Пока что можете считать, что это адреса (хотя это не так), на которые в результате исполнения транзакции будут "отправлены" средства. Выходов также может быть несколько и каждому из них указывается своя сумма.

На картинке ниже создается новая транзакция **C**, которая ссылается на две входящие - **A** и **B**. В результате на входе у транзакции получается **0.008 BTC**, которые потом разделяются на два выхода - на первый адрес отправляется **0.003 BTC**, а на второй **0.004 BTC**. 

!["Inputs,outputs"](http://static.righto.com/images/bitcoin/transaction_diagram.png)

Возможность указать сразу несколько выходов - это очень важная фича, потому что транзакцию можно использовать как вход только один раз и только целиком. То есть если у вас есть входящая транзакция на 10 BTC, а вам нужно потратить только 8 из них в каком-нибудь Старбаксе - вы просто создаете транзакцию с одним входом и двумя выходами: на 8 BTC в магазин и на 2 BTC обратно на свой адрес. Если же вы создадите транзакцию, в которой сумма выходов меньше суммы входов (как на картинке), то разница отправляется на адрес майнера, записавшего вашу транзакцию в блок.

### Fee

Именно эта разница между суммой входов и суммой выходов и называется **transaction fee**, то есть комиссия за транзакцию. Она является вторым по важности источником дохода для майнеров и именно от нее зависит время включения транзакции в блокчейн. Это связано с тем, что у каждого майнера существует некоторый пул непроверенных транзакций, которые претендуют на попадание в блок, и, как правило, майнер просто сортирует их по убыванию комиссии, тем самым максимизируя свою прибыль. Поэтому чем больше комиссия, тем выше вы окажетесь в очереди и тем быстрее пройдет ваш платеж.

### UTXO

Как только новая транзакция занесена в блокчейн, она может быть использована в качестве входа. Для таких, пока еще непотраченных транзакций, существует специальное название - **UTXO**, то есть *unspent transaction output*. Как вы уже поняли, каждая транзакция может быть использована в качестве входа только один раз, поэтому на практике интерес представляют именно непотраченные транзакции, а уже использованные хранятся скорее как дань безопасности системы.

**BTW** под UTXO также часто подразумевают весь массив непотраченных транзакций, хотя воспитанные молодые люди должны писать *UTXO pool* ну или в крайнем случае *UTXO set*.

Возвращаясь к началу статьи - теперь для вас должно быть очевидно, что для подсчета баланса адреса не нужно перебирать весь блокчейн, а достаточно обойтись только перебором UTXO pool, что очевидно быстрее.

### Transaction structure
Общий вид транзакции описан в [официальной спецификации протокола](https://en.bitcoin.it/wiki/Protocol_documentation#tx), здесь же я приведу живой пример, взятый из блога [Ken Shirriff](http://www.righto.com/) (в скобках написан размер для каждого поля в байтах).

<table>
<tr><td colspan=2>version (4)</td><td>01 00 00 00 // Always</td></tr>
<tr><td colspan=2>input count (1+)</td><td>01</td></tr>
<tr><td rowspan=5>input</td><td>previous output hash (32)<br></td><td>48 4d 40 d4 5b 9e a0 d6 52 fc a8 25 8a b7 ca a4 25 41 eb 52 97 58 57 f9 6f b5 0c d7 32 c8 b4 81</td></tr>
<tr><td>previous output index (4)</td><td>00 00 00 00</td></tr>
<tr><td>script length (1+)</td><td></td></tr>
<tr><td>scriptSig (?)</td><td>script containing signature</td></tr>
<tr><td>sequence (4)</td><td>ff ff ff ff // Always</td></tr>
<tr><td colspan=2>output count (1+)</td><td>01</td></tr>
<tr><td rowspan=3>output</td><td>value (8)</td><td>62 64 01 00 00 00 00 00</td></tr>
<tr><td>script length (1+)</td><td></td></tr>
<tr><td>scriptPubKey (?)</td><td>script containing destination address</td></tr>
<tr><td colspan=2>block lock time (4)</td><td>00 00 00 00</td></tr>
</table>

По какой-то [загадочной причине](http://bitcoin.stackexchange.com/questions/2063/why-does-the-bitcoin-protocol-use-the-little-endian-notation), *value* и *previous output hash* должны быть представлены в little endian форме, то есть в нашем случае хэш [транзакции на входе](https://blockchain.info/tx/81b4c832d70cb56ff957589752eb4125a4cab78a25a8fc52d6a09e5bd4404d48) вообще-то равен **81 b4 c8 32...**, хотя в транзакции он записывается в виде **...32 c8 b4 81**. Точно так же сумма транзакции равна **0.00091234** BTC или **0x016462** в hex, но в протоколе она записывается как **62 64 01 00 00 00 00 00**.

**BTW** хэш транзакции считается крайне просто - берете всю транзакцию в виде последовательности байт (в примере выше получается строка вида **010000000148....00**), два раза считаете от нее хэш SHA256 и представляете результат в little endian форме.

[*block lock time*](http://bitcoin.stackexchange.com/questions/46495/what-does-lock-time-means) - этот параметр довольно редко используется на практике. Если он не равен 0 и меньше 500 млн - то это номер блока, начиная с которого данной транзакцией можно воспользоваться в качестве входа. Так как в среднем блоки появляются раз в 10 минут, то несложно прикинуть время, когда транзакция "откроется".

Если lock time больше 500 млн, то он воспринимается как UNIX timestamp, начиная с которого транзакция станет доступна. В нашем случае там стоит 0, то есть транзакция доступна сразу.

*[sequence](https://bitcoin.org/en/glossary/sequence-number)* - эта фича больше не используется, почитать про нее можно [здесь](http://bitcoin.stackexchange.com/questions/2025/what-is-txins-sequence).

Параметры со словом script в названии существенно сложнее, о них будет рассказано ниже.

### SCRIPT

Вы уже знаете, что в сети Bitcoin существует механизм, основанный на некоторых криптостойких алгоритмах + паре приватный / публичный ключ, который позволяет создать систему, в которой только владелец приватного ключа может воспользоваться монетами, ассоциированными с адресом, полученным из этого ключа. Сейчас я покажу, как это реализуется "под капотом".

Начнем с того, что внутри Bitcoin существует свой собственный язык программирования, названный Script. Вот что о нем пишет [Bitcoin wiki](https://en.bitcoin.it/wiki/Script):

> Bitcoin uses a scripting system for transactions. Forth-like, Script is simple, stack-based, and processed from left to right. It is purposefully not Turing-complete, with no loops.

Суть в том, что язык прост как пробка, stack-based и Тьюринг-неполный. Вот пример типичной программы:

```
2 3 OP_ADD 5 OP_EQUAL
```

Каждая инструкция называется opcode - [всего их порядка 80](https://en.bitcoin.it/wiki/Script#Words), так что язык действительно довольно примитивен. На картинке ниже изображен процесс исполнения программы `2 3 OP_ADD 5 OP_EQUAL`, думаю что все понятно без комментариев:

![opadd](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0502.png)


### Lock & unlock transaction

Вернемся к языку чуть позже, а сначала давайте разберемся, зачем он здесь вообще нужен.
Для этого вспоминаем структуру транзакции и два параметра: **scriptSig** и **scriptPubKey**. В отличие от других параметров, назначение этих двух вообще не очевидно, и ИМХО это в принципе самое сложное, что есть в Bitcoin.

Я видел много попыток объяснить (как правило неудачных), что же из себя блокировка транзакции в Bitcoin и как ее нужно воспринимать на интуитивном уровне. Тем не менее я рискну и попробую привести еще одну аналогию. Для этого давайте рассмотрим *завещание*, вроде такого:

> 1.000.000$ переходят к **A** только после того, как ей исполнится 18 лет

В этом случае, сам текст завещания - это некоторое условие, при котором можно воспользоваться деньгами (читай *можно воспользоваться транзакцией на 1.000.000$ как входом*), а ксерокопия паспорта в 19 лет - это доказательство того, что условие выполнено и самое время получить деньги.

Именно для того, чтобы **задать условие, при котором можно будет потратить транзакцию, и для возможности подтвердить то, что условие выполнено** и нужен SCRIPT, приватные / публичные ключи и прочие сложности.

В случае Bitcoin, завещание - это **locking script**, который указывается в транзакции внутри поля [pk_script](https://en.bitcoin.it/wiki/Protocol_documentation#tx). Его еще часто называют **scriptPubKey** из-за того, что чаще всего это программа, содержащая публичный ключ или адрес, хотя вообще говоря он может не иметь ничего общего с криптографией или например просто быть пустым, это тоже допускается.

Некоторое "доказательство" того, что условие из **locking script** выполнено, называется **unlocking script**, пишется в поле signature script и часто называется **scriptSig**, догадайтесь почему.

Сам механизм проверки скрипта на валидность очень прост - для этого просто соединяется **unlocking script** + **locking script** и получившаяся программа запускается как одно целое. Если после исполнения сверху стека остажется `TRUE` - то транзакция валидна, и невалидна в любом другом случае.

### Password-based script

Для начала давайте напишем какой-нибудь максимально простой скрипт, чтобы окончательно понять, как это все работает. Идея будет в том, чтобы заблокировать деньги с помощью какого-нибудь пароля, например **dummy_password**. Сам пароль будет храниться в locking script в виде хэша SHA-256 и для того, чтобы *разблокировать* транзакцию, нужно будет указать пароль в чистом виде.

Для того, чтобы эксперементировать со SCRIPT, установим NPM пакет [bitcoin-script](https://www.npmjs.com/package/bitcoin-script) - `sudo npm install -g bitcoin-script`. Вот пример его работы:

```javascript
var unlock = require('bitcoin-script').unlock;
var scriptSig = 'OP_1';
var scriptPubKey = 'OP_VERIFY';
unlock(scriptSig, scriptPubKey);
// => true 
```

В нашем случае в качестве *locking script* укажем `OP_SHA256 146512fc46367d414ad21a0e1efc8bbd798a975f12b8384510f2d1ad5d8c299c OP_EQUALVERIFY`, где длинная строка - это `SHA256('dummy_password')`. Попробуем запустить скрипт, записав в *unlocking script* `dummy_password`:

```javascript
var unlock = require('bitcoin-script').unlock;
var unlocking_script = 'dummy_password';
var locking_script = 'OP_SHA256 146512fc46367d414ad21a0e1efc8bbd798a975f12b8384510f2d1ad5d8c299c OP_EQUALVERIFY';
console.log(unlocking_script + ' ' + locking_script);
// 'dummy_password OP_SHA256 146512fc46367d414ad21a0e1efc8bbd798a975f12b8384510f2d1ad5d8c299c OP_EQUALVERIFY'
unlock(unlocking_script, locking_script); // true
```

### Pay to Public Key Hash (P2PKH)

P2PKH используется наверное в 99 транзакциях из 100, так что стоит понимать, как он работает. Вот его общий вид: 

![p2pkh2](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0501.png)

Этот скрипт известен наверное с самого появления Bitcoin и возможно придуман самим Сатоши. Именно он выполняет ту задачу, о которой я писал выше: сделать так, чтобы только владелец приватного ключа смог воспользоваться монетами, ассоциированными с адресом, полученным из этого ключа.

На пальцах это выглядит следующим образом: пусть вашему другу **B** принадлежит приватный ключ **P**. Он получает из него публичный ключ **K**, адрес **A** и сообщает адрес вам. Далее вы отправляете на адрес **A** 1 BTC и в поле **locking script** пишите примерно следующее:

> Только тот, кто владеет приватным ключом для адреса **A** сможет потратить эту транзакцию. В качестве доказательства предоставьте, во-первых, публичный ключ **K**, а во-вторых подпись моей транзакции этим самым приватным ключом.

Когда **B** решит использовать вашу транзакцию в качестве входа, то он создаст свою, например на 0.5 BTC, а в поле **unlocking script** вставит подпись вашей транзакции своим приватным ключом **P** - `<sig>` и свой публичный ключ **K** - `<PubK>`.

![p2pkh1](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0503.png)
![script](http://orm-chimera-prod.s3.amazonaws.com/1234000001802/images/msbt_0504.png)

1. Подпись транзакции добавляется в стек
2. Публичный ключ добавляется в стек
3. `OP_DUP` берет верхний элемент стека и дублирует его, то есть теперь в стеке сверху два публичных ключа
4. `OP_HASH160` заменяет верхний элемент стека на его хэш `RIPEMD160(SHA256(x))`
5. В стек добавляется такой же хэш публичного ключа, но уже посчитанный отправителем транзакции
6. `OP_EQUALVERIFY` удаляет два верхних элемента стека, и если они не равны, то исполнение программы прерывается с ошибкой
7. `OP_CHECKSIG` проверяет соответствие подписи и публичного ключа, если все верно, то удаляет их из стека и добавляет `TRUE`

### Links

- [How are transaction hashes calculated?](http://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated)
- [The Bitcoin Script Playground](http://www.crmarsh.com/script)
- [NPM bitcoin-script package](https://www.npmjs.com/package/bitcoin-script)
